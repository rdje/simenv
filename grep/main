#!bash
# ==========================================================================================
# Copyright (C) 2022 Richard DJE
#
# This file is part of simenv
#
# simenv is free software: you can redistribute it and/or modify it under the terms
# of the GNU General Public License as published by the Free Software Foundation, either 
# version 3 of the License, or any later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along with this program. 
# If not, see <https://www.gnu.org/licenses/>.
# ==========================================================================================

function get_cwd   { echo $cwd; }
function get_cmdir { echo $(dirname $main); }
function get_local { echo $(get_cmdir)/.local; }
function get_run   { echo $(get_cmdir)/.run; }

# Function: usage
#
function usage
{
  if [[ -z $1 ]]; then
  cat <<USAGE | sed -r 's/grep|--?[[:alnum:]-]+|-x.|[][]/\\e[1m&\\e[0m/g
                        s/^(\s*)(list|add|rm|\<name\>|up|down)/\1\\e[1m\2\\e[0m/
                        s/(\|)(remove)/\1\\e[1m\2\\e[0m/
                        s/(ext|file|dir)glob|eregex|sub|options|cmd|commands|parameters|path/\\e[4m&\\e[0m/g
                        s/(name|N|U|D)(=|\|)/\\e[4m\1\\e[0m\2/g
                        s/(=)(name)/\1\\e[4m\2\\e[0m/
                        s/(\|)(N)/\1\\e[4m\2\\e[0m/
                        s/.*/echo -e "&"/e'

usage: simenv grep [options] eregex... | subcmd [parameters]
  
  options:
    
    -x  extglob{,extglob}
        Ignore files ending with the comma separated extension glob patterns

    -xf fileglob{,fileglob}
        Ignore files matching the comma separated file glob patterns

    -xd dirglob{,dirglob}
        Ignore directories matching the comma separated glob patterns

    -d  name|N
        Only search the directory whose number or logical name is provided

    -h
    -n
    -R
    -i
        Ignore case
    -I  
        Ignore binary files
    -s
        Suppress error messages about nonexistent or unreadable files.


  subcommands:
    
    list
    add [name=]path...
    rm|remove [name|N]
    name N=name...
    up name|N [U=1], 
    down name|N [D=1]

USAGE
  else
    cat <<SHORT | sed -r 's/(-\s+)(grep)/\1\\e[1m\2\\e[0m/g'  \
                | sed -r 's/(are )(not)/\1\\e[1m\2\\e[0m/'    \
                | sed 's/.*/echo -e "&"/e'
    - grep [-h|--help] ...
          Small wrapper around grep, which only exposes what's necessary.
          It provides custom and shorter options to help filter files and directories.
          But most importantly, directories to search are not specified on the command line but stored in a local file.
          It is assumed that they are the ones you'll search all the time. There are subcommands to manage them.

SHORT
  fi
    
  exit
}


# Function: grep [options] eregex
#
#   Positional arguments may be intermixed with options
#
function main
{
  echo "$FUNCNAME: PWD<$PWD>"
  # Display usage and quit if no argument
  if (($# == 0)); then
    usage
  fi
  
  for v in "$@"
  do
   if [[ $debug ]]; then echo "initial: <$v>"; fi
  done

  if [[ $debug ]]; then echo; fi

  # Collect the options and positional arguments
  opts=$(getopt -n simenv -a -o ihnRIsx:d: -l xf:,xd:,ad,add-directory: -- "$@")
  if (($? && $? < 4)); then
    usage
  fi


  eval set -- $opts

  for a
  do
    if [[ $debug ]]; then echo "getopt: <$a>"; fi
  done

  if [[ $debug ]]; then echo; fi

  local k=0
  while (($#))
  do
    if [[ $debug ]]; then echo -e "\e[31mk: $k  <$1>\e[0m"; fi
    case $1 in
      -x)
        for ext in $(echo $2 | sed 's/,/\n/g' | sed 's/^\.//')
        do
          if [[ $debug ]]; then echo "ext<$ext>"; fi

          extglobs[$((extglob_id))]=$ext
          ((extglob_id++))
        done

        shift 2
        ;;

      --xf)
        exclude_file $1 $2
        shift 2
        ;;

      --xd)
        exclude_dir $1 $2
        shift 2
        ;;

      -i)
        ignore_case=1;
        if [[ $debug ]]; then echo "ignore_case<1>"; fi
        shift;
        ;;

      -I)
        ignore_binary=1;
        if [[ $debug ]]; then echo "ignore_binary<1>"; fi
        shift;
        ;;

      -h)
        no_filename=1;
        if [[ $debug ]]; then echo "no_filename<1>"; fi
        shift;
        ;;

      -R)
        symlink_recurse=1;
        if [[ $debug ]]; then echo "symlink_recurse<1>"; fi
        shift;
        ;;

      -n)
        linenum=1;
        if [[ $debug ]]; then echo "linenum<1>"; fi
        shift;
        ;;

      -s)
        no_messages=1;
        if [[ $debug ]]; then echo "no_messages<1>"; fi
        shift;
        ;;

      --ad|--add-directory)  
        if ((k == 1)); then
          shift
          add_directory "$1"
          return
        fi
        ;;

      -d)
        sd=$2;
        shift 2;
        ;;

      --) end_of_options=1
          if [[ $debug ]]; then echo "########## End Of Options ##########"; fi
          shift
          ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option '\e[1;31m$1\e[0m'"
          usage
          ;;

      *)  if ((k == 1)); then
            if [[ $1 =~ ^add((-|_)dir(ectory)?)?$ ]]; then
              shift
              add_directory "$@"
              return
            fi

            if [[ $1 =~ ^list((-|_)dir(ectory)?)?$ ]]; then
              shift
              list_directory "$@"
              return
            fi

            if [[ $1 =~ ^(rm|remove)((-|_)dir(ectory)?)?$ ]]; then
              shift
              rm_directory "$@"
              return
            fi

            if [[ $1 =~ ^name$ ]]; then
              shift
              name_directory "$@"
              return
            fi

            if [[ $1 =~ ^up$ ]]; then
              shift
              up_directory "$@"
              return
            fi

            if [[ $1 =~ ^down$ ]]; then
              shift
              down_directory "$@"
              return
            fi

            if [[ $1 =~ ^usage|help$ ]]; then
              shift
              usage "$@"
              return
            fi

          fi

          params[$((posid))]=$1
          ((posid++))
          if [[ $debug ]]; then echo "positional parameter: <$1>"; fi
          shift
          ;;
    esac

    ((k++))
  done

  if (($(has_empty_dirlist) == 0)); then
    eval grep -E                        \
              --color=always            \
              ${ignore_case:+-i}        \
              ${ignore_binary:+-I}      \
              ${no_filename:+-h}        \
              ${no_messages:+-s}        \
              ${linenum:+-n}            \
              $(if ((symlink_recurse)); then echo -R; else echo -r; fi)         \
              $(for e in "${extglobs[@]}";  do echo "--exclude=*.'$e'"; done)   \
              $(for f in "${fileglobs[@]}"; do echo "--exclude='$f'"; done)     \
              $(for d in "${dirglobs[@]}";  do echo "--exclude-dir='$d'"; done) \
              $(for p in "${params[@]}";    do echo "-e '$p'"; done)            \
              $(cat_dirlist $sd)
  else
    echo -e "\e[1;31m-E-\e[0m No registered directory"

    echo  \
"
    Use either one of

      simenv grep add-dir dirpath...
      simenv grep --add-dir dirpath[,dirpath]*
    "
  fi

}


# Function: init
#
function init
{
  mkdir -p $(get_local) $(get_run)
  cd $(get_run)
  #echo rm -rf *
  echo "$cwd" > cwd
}


function get_dirlist { echo $(get_local)/dirlist; }

# Function: add_directory [name=]path...
#
function add_directory
{
  #echo "call-stack: ${FUNCNAME[@]}"
  if ((!$#)); then
    echo -e "\e[1;31m-E-\e[0m No directory provided."
    exit 1
  fi

  echo "<$#> <$*> cwd<$(<cwd)> pwd<`pwd`>"
  touch $(get_dirlist)
  touch named

  local b_linec=$(wc -l $(get_dirlist) | cut -d' ' -f1)

  # save named paths in the 'named' variable
  local pathid=0
  for p; do
    if [[ $p =~ ^[[:alpha:]][[:alnum:]_]*= ]]; then
      #echo "Named: $p"
      setvar -a named "$(echo -e "$(grep -o '/.*$' <<<$p)\t$(grep -o '^[^=]\+' <<<$p)")"

      newpaths[$((pathid))]="$(grep -o '/.*$' <<<$p)"
    else
      #echo "Not named: $p"
      newpaths[$((pathid))]=$(
        if ! [[ $p =~ ^/ ]]; then
          # $p is relative to the startup directory
          echo $(<cwd)/$p
        else
          echo $p
        fi
      )
    fi    
    
    #echo "newpaths[$pathid]=${newpaths[$pathid]}; <$p>"
    ((pathid++))
  done

  set -- "${newpaths[@]}"

  local cato=$(cat $(get_dirlist) <(readlink -e "$@") | sed -r '\#^[[:alpha:]]# ! s#.*/([^/]+)#\L\1\E &#' | while read name file; do
      name=$(grep -o '^[[:alnum:]_]\+' <<<$name)

      #echo "file: $name $file"

      local Name
      match=$(grep "^$file" named)
      if [[ $match ]]; then
        Name=$(grep -o '[[:alnum:]_]\+$' <<<$match)
      fi

      #echo "file:---> oldname<$name>   newname<$Name>   <$file>"
      if [[ $Name ]]; then
        name=$Name
      fi

      printf "%-8s %s\n" $name $file
    done | sort -k2 -u
  )

  echo "$cato" > $(get_dirlist)

  local a_linec=$(wc -l $(get_dirlist) | cut -d' ' -f1)

  local ignored=0
  if ((a_linec < b_linec + $#)); then
    for d in "$@"
    do
      if [[ -z $(readlink -e $d) ]]; then
        echo -e "\e[1;31m-W-\e[0m Directory \e[1m$d\e[0m does not exist, ignored."
        ((ignored++))
      fi
    done

    if ((!ignored)); then
      echo -e "\e[1;31m-W-\e[0m No new directory added."
    fi
  fi
}


# Function: exclude_file
#
function exclude_file
{
  _xfid=$((_xfid+1))

  local opt=$1
  local value=$2

  if [[ $value =~ ^[^,/]+(,[^,/]+)*$ ]]; then
    for file in $(echo $value | sed 's/,/ /g')
    do
      if [[ $debug ]]; then echo "file<$file>"; fi

      fileglobs[$((fileglob_id))]=$file
      ((fileglob_id++))
    done
  else
    case $_xfid in
      1) suffix=st;;
      2) suffix=nd;;
      3) suffix=rd;;
      *) suffix=th;;
    esac

    echo -e "\e[1;31m-E-\e[0m Syntax error with value '\e[1m$value\e[0m' of $_xfid$suffix '\e[1m$opt\e[0m' option"
    echo -e "\e[1m-I-\e[0m Probably due to the presence of '\e[1m/\e[0m's"
    exit 2
  fi
} # exclude_file


# Function: exclude_dir
#
function exclude_dir
{
  _xdid=$((_xdid+1))

  local opt=$1
  local value=$2

  if [[ $value =~ ^[^,/]+(,[^,/]+)*$ ]]; then
    for dir in $(echo $value | sed 's/,/ /g')
    do
      if [[ $debug ]]; then echo "dir<$dir>"; fi

      dirglobs[$((dirglob_id))]=$dir
      ((dirglob_id++))
    done
  else
    case $_xdid in
      1) suffix=st;;
      2) suffix=nd;;
      3) suffix=rd;;
      *) suffix=th;;
    esac

    echo -e "\e[1;31m-E-\e[0m Syntax error with value '\e[1m$value\e[0m' of $_xdid$suffix '\e[1m$opt\e[0m' option"
    echo -e "\e[1m-I-\e[0m Probably due to the presence of '\e[1m/\e[0m's"
    exit 2
  fi
} # exclude_dir


# Function: list_directory
#
function list_directory
{
  cat_dirlist | nl
}


# Function: rm_directory  [name|N]
#
function rm_directory
{
  if [[ $debug ]]; then echo "$FUNCNAME: <$#> <$@>"; fi

  local id=$1

  if [[ -z $id ]]; then
    PS3="Select a directory to delete: "
    select d in $(cat_dirlist)
    do
      if ((debug)); then echo "d<$d><$REPLY><$?>"; fi
      if (($? == 0)); then
        if [[ "$REPLY" =~ ^[[:digit:]]+$ ]] && ((REPLY <= $(cat_dirlist | wc -l | cut -d' ' -f1))) && [[ $d ]]; then
          break
        else
          return
        fi
      else
        return
      fi
    done
    
    newlist=$(sed -rn "$REPLY ! p" <$(get_dirlist))
    echo "$newlist" > $(get_dirlist)
  else
    b_wc=$(wc -l $(get_dirlist) | cut -d' ' -f1)

    removed=$(cat_dirlist | nl -nln | if [[ $id =~ ^[[:alpha:]] ]]; then
        sed -r '/\s+'$id'\s/d'
      else
        sed -r '/^'$id'\s/d'
      fi)
   
    a_wc=$(echo "$removed" | wc -l | cut -d' ' -f1)

    if ((b_wc == a_wc)); then
      echo -e "\e[1m-W-\e[0m No match found for '\e[1m$id\e[0m'"
      return
    fi

    echo "$removed" | sed -r 's/^[[:digit:]]+\s+//' | tee $(get_dirlist) | nl
  fi
}

function setvar
{
  local setid
  while (($#)); do
    case $1 in
      -a) local append=1;
          shift
          ;;

      # Collect all positional arguments
      *)  local setpos[$((setid))]="$1"
          ((setid++))
          shift
          ;;
    esac
  done

  set -- "${setpos[@]}"

  if [[ $debug ]]; then echo "$FUNCNAME: #<$#> pos<${setpos[@]}> append<$append>" 1>&2; fi

  if (($# != 2)); then
    echo $FUNCNAME requires exactly two arguments: "<name> <value>"
    exit 1
  fi

  if [[ $debug ]]; then echo "$FUNCNAME: Setting $1 to '$2'" 1>&2; fi
  
  if ((append)); then
    echo "$2" >> $1
  else
    echo "$2" > $1
  fi
}

export -f setvar


# Function: name_directory
#
function name_directory
{
  
  if [[ $debug ]]; then echo "$FUNCNAME: <$#> <$@>"; fi

  if ((!$#)); then
    echo -e "usage: simenv grep name N=name..." | sed 's/name/\\e[1m&\\e[0m/; s/N/\\e[4m&\\e[0m/; s/name/\\e[4m&\\e[0m/2; s/.*/echo -e "&"/e'
    return
  fi

  setvar maxid 0
  eval num_names=($(grep -o '\S\+' <<<"$@" | sed 's/=/ /' | while read id va; do
      if ((id > $(<maxid))); then
        setvar maxid $id
        
        if [[ $debug ]]; then echo $FUNCNAME: new max is $(<maxid) 1>&2; fi
      fi

      echo "[$id]=$va"
    done
  ))


  dirlist=`cat_dirlist  | nl -nln | while read linenum name_path; do
    name=$(grep -o '^\w\+' <<<$name_path)
    path=$(grep -o '/.*$'  <<<$name_path)

    if [[ ${num_names[$linenum]} ]]; then
      #if [[ $name_path =~ ^/ ]]; then
      #  echo -e "\tNo name attached yet, \e[1m${num_names[$linenum]}\e[0m will be applied" 
      #else
      #  echo -e "\tCurrent name will be replaced" 
      #fi
      
      printf "%-8s%s\n" "${num_names[$linenum]}" $path
    else
      printf "%-8s%s\n" "$name" $path
    fi 
  done`

  echo "$dirlist" | tee $(get_dirlist) | nl
}

# Function: up_directory N|name [U=1]
#
function up_directory
{
  #echo "$FUNCNAME: <$#> <$@>"
  
  if (($# == 0 || $# > 2)); then
    echo  "usage: simenv grep up N|name [U=1]" | sed -r 's/-E-/\\\\e[1;31m&\\\\e[0m/; s/up/\\\\e[1m&\\\\e[0m/; s/N|name|U/\\\\e[4m&\\\\e[0m/g' | xargs echo -e
    return 
  fi

  id=$1
  up=${2:-1}

  filtered=$(cat_dirlist | nl -nln | if [[ $id =~ ^[[:alpha:]] ]]; then
      sed -r '/\s+'$id'\s.*/ {s/.*/setvar  selected "&"/e; d}'
    else
      sed -r '/^'$id'\s+.*/  {s/.*/setvar  selected  "&"/e; d}'
    fi
  )

  cpos=$(grep -o '^[[:digit:]]\+' selected)
  npos=$((cpos - up))
  if ((npos <= 0)); then
    npos=1
  fi

  #echo "cpos<$cpos> --> npos<$npos>"
  echo "$filtered" | sed -r '/^'$npos'/i'"$(<selected)" | sed -r 's/^.*\s+([[:alpha:]].*)/\1/' | tee $(get_dirlist) | nl
}

# Function: down_directory N|name [D=1]
#
function down_directory
{
  #echo "$FUNCNAME: <$#> <$@>"
  if (($# == 0 || $# > 2)); then
    echo  "usage: simenv grep down N|name [U=1]" | sed -r 's/-E-/\\\\e[1;31m&\\\\e[0m/; s/down/\\\\e[1m&\\\\e[0m/; s/N|name|U/\\\\e[4m&\\\\e[0m/g' | xargs echo -e
    return 
  fi

  id=$1
  down=${2:-1}

  filtered=$(cat_dirlist | nl -nln | if [[ $id =~ ^[[:alpha:]] ]]; then
      sed -r '/\s+'$id'\s.*/ {s/.*/setvar  selected "&"/e; d}'
    else
      sed -r '/^'$id'\s+.*/  {s/.*/setvar  selected  "&"/e; d}'
    fi
  )

  cpos=$(grep -o '^[[:digit:]]\+' selected)
  npos=$((cpos + down))
  dirlist_lcnt=$(wc -l $(get_dirlist) | cut -d' ' -f1)
  if ((npos >= $dirlist_lcnt)); then
    npos=$dirlist_lcnt
  fi

  #echo "cpos<$cpos> --> npos<$npos>"
  echo "$filtered" | sed -r '/^'$npos'/a'"$(<selected)" | sed -r 's/^.*\s+([[:alpha:]].*)/\1/' | tee $(get_dirlist) | nl
}

# Function: cat_dirlist
#
function cat_dirlist
{
  #echo "$FUNCNAME: arg<$1>"
  if [[ -s $(get_dirlist) ]]; then
    local id=$1

    cat $(get_dirlist) | if [[ -z $id ]]; then
      cat
    else
      if [[ $id =~ ^[[:alpha:]] ]]; then
        sed -rn '/^'$id'\>/p' 
      else
        nl -nln | sed -rn '/^'$id'\s/p'
      fi | sed -r 's#.*\s(/.*)$#\1#'
    fi
  fi
}

export -f cat_dirlist


# Function: has_empty_dirlist
#
function has_empty_dirlist
{
  if [[ -s $(get_dirlist) ]]; then
    echo 0
  else
    echo 1 
  fi
}


init
main "$@"


